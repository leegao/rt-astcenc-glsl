#version 450
#extension GL_KHR_shader_subgroup_clustered : require
#extension GL_KHR_shader_subgroup_arithmetic : require

layout(local_size_x = 16, local_size_y = 4, local_size_z = 1) in;

#define COLOR_BITS_RGB_1P 7
#define COLOR_BITS_RGBA_1P 7
#define COLOR_BITS_RGB_2P 5
#define COLOR_BITS_RGBA_2P 3

#define WEIGHT_BITS_RGB_1P 4
#define WEIGHT_BITS_RGBA_1P 3
#define WEIGHT_BITS_RGB_2P 2
#define WEIGHT_BITS_RGBA_2P 3

/*
 * LUT mapping quantization bits to its 3-bit color mode ID.
 */
const uint COLOR_QUANT_MODE_LUT[6] = uint[](
    0x0,       // RANGE_8, 3b
    0x2,       // RANGE_16, 4b
    0x1,       // RANGE_32, 5b
    0x3,       // RANGE_64, 6b
    0x6,       // RANGE_128, 7b
    0x7        // RANGE_256, 8b
);

/*
 * LUT mapping quantization bits to its 4-bit weight mode ID.
 */
const uint WEIGHT_QUANT_MODE_LUT[6] = uint[](
    0x3,       // RANGE_8, 3b
    0x5,       // RANGE_16, 4b
    0x7,       // RANGE_32, 5b
    0xB,       // RANGE_64, 6b
    0xD,       // RANGE_128, 7b
    0xF        // RANGE_256, 8b
);

layout(std140, binding = 0) uniform CParams {
    uint g_num_total_blocks;
    uint g_use_pca;
    float g_maximum_PC2_spread;
};

// Input: Uncompressed pixels (B, 16, 4)
layout(std430, binding = 1) buffer readonly InBlocks {
    vec4 g_in_blocks[]; // Accessed as [global_block_id * 16 + pixel_idx]
};

// Output: Compressed 128-bit blocks
layout(std430, binding = 2) buffer writeonly OutBlocks {
    uvec4 g_out_compressed_blocks[]; // 4x 32-bit uints = 128 bits
};

// Output: Decoded 4x4 RGBA8 pixel blocks
layout(std430, binding = 3) buffer writeonly OutDecodedPixels {
    vec4 g_out_decoded_pixels[]; // Accessed same as g_in_blocks
};

// Input LUT: 65536-entry (ideal map -> seed)
// Bind as R16UI texture format
layout(binding = 4) uniform usamplerBuffer g_lut_ideal_to_seed;

// Input LUT: 1024-entry (seed -> mask)
// Bind as R16UI texture format
layout(binding = 5) uniform usamplerBuffer g_lut_seed_to_mask;

// 4 blocks * 16 pixels/block = 64 pixels
shared vec4 s_block_pixels[64];

// 4 blocks * 128b (4 uvecs) for the final packed astc block
shared uvec4 s_packed_block[4];

uint quantize_to_index(float value, uint bits) {
    if (bits == 0) return 0;
    float max_val = float((1 << bits) - 1);
    return uint(round(clamp(value, 0.0, 1.0) * max_val));
}

float dequantize_from_index(uint index, uint bits) {
    if (bits == 0) return 0.0;
    float max_val = float((1 << bits) - 1);
    return float(index) / max_val;
}

uint get_bits(uvec4 block, uint offset, uint num_bits)
{
    if (num_bits == 0 || num_bits > 32) {
        return 0;
    }

    uint mask = (num_bits == 32) ? 0xFFFFFFFF : (1 << num_bits) - 1;

    uint dword_index = offset / 32;
    uint bit_in_dword = offset % 32;

    uint value = (block[dword_index] >> bit_in_dword);
    uint bits_in_first_dword = 32 - bit_in_dword;
    if (bits_in_first_dword < num_bits)
    {
        uint bits_from_next_dword = num_bits - bits_in_first_dword;
        uint next_dword_mask = (1 << bits_from_next_dword) - 1;
        uint overflow_bits = (block[dword_index + 1] & next_dword_mask);

        // Combine them
        value |= (overflow_bits << bits_in_first_dword);
    }

    return value & mask;
}

/**
 * Atomically writes N bits from a value into a SHARED uvec4 block within s_packed_block
 * This allows the packing functions to parallelize the set_bits
 */
void set_bits_atomic_shared(uint block_idx, uint value, uint offset, uint num_bits)
{
    if (num_bits == 0 || num_bits > 32) {
        return;
    }

    uint mask = (num_bits == 32) ? 0xFFFFFFFF : (1u << num_bits) - 1u;
    uint val_masked = (value & mask);
    uint dword_index = offset / 32;
    uint bit_in_dword = offset % 32;

    atomicOr(s_packed_block[block_idx][dword_index], (val_masked << bit_in_dword));

    uint bits_in_first_dword = 32 - bit_in_dword;
    if (bits_in_first_dword < num_bits)
    {
        uint overflow_bits = val_masked >> bits_in_first_dword;
        atomicOr(s_packed_block[block_idx][dword_index + 1], overflow_bits);
    }
}

/**
 * Encodes the 11-bit ASTC block mode header for a 4x4, 1-partition block.
 * 
 * Block Mode [10:0] structure for 4x4, 1-partition:
 * [10:9] : 00   (Selects 1-plane, not dual-plane)
 * [8:6]  : color_mode (3 bits, from get_color_quant_mode)
 * [5:2]  : weight_mode (4 bits, from get_weight_quant_mode)
 * [1:0]  : 00   (Selects 4x4 block size)
 */
uint block_mode_p1(uint color_bits, uint weight_bits) {
    uint color_mode = COLOR_QUANT_MODE_LUT[color_bits - 3];
    uint weight_mode = WEIGHT_QUANT_MODE_LUT[weight_bits - 3];
    uint quant_mode_7bit = (color_mode << 4) | weight_mode;
    return quant_mode_7bit << 2;
}

/**
 * Encodes the 11-bit ASTC block mode header for a 4x4, 2-partition block.
 * NOTE: The weight range (R_M) is IMPLIED by the color range for 2-partition
 * blocks (e.g., R8-R32 color -> R8 weight, R64 color -> R6 weight).
 *
 * Block Mode [10:0] structure for 4x4, 2-partition:
 * [10:9] : 00   (Selects 1-plane, not dual-plane)
 * [8:6]  : 000  (Fixed for 2-partition)
 * [5]    : 0    (Fixed for 2-partition)
 * [4:2]  : color_mode (3 bits, from get_color_quant_mode)
 * [1:0]  : 01   (Selects 4x4 block size, 2/3/4 partitions)
 */
uint block_mode_p2(uint color_bits) {
    uint color_mode = COLOR_QUANT_MODE_LUT[color_bits - 3];
    return (color_mode << 2) | 0x01;
}

/**
 * Packs a 4x4 RGB block (1/2)-partition, rgb(a) block using color_bits, weight_bits quantization
 */
void pack_astc_block_parallel(uint w_index, uint c_index, uint components, bool use_p2, uint color_bits, uint weight_bits, bool use_rgba, uint astc_seed)
{
    uint pixel_idx = gl_LocalInvocationID.x;
    uint block_idx = gl_LocalInvocationID.y;
    uint endpoint_lut_base = block_idx * 16;
    uint offset = use_p2 ? 27 : 17;

    if (pixel_idx == 0) {
        s_packed_block[block_idx] = uvec4(0, 0, 0, 0);
        uint CEM = use_rgba ? 0xD /* rgba_ldr */ : 0x4 /* rgb_ldr */;
        if (!use_p2) {
            set_bits_atomic_shared(block_idx, block_mode_p1(color_bits, weight_bits), 0, 11); // [0..10] Block Mode
            set_bits_atomic_shared(block_idx, 0x0, 11, 2);   // [11..12] partitions = 1
            set_bits_atomic_shared(block_idx, CEM, 13, 4);   // [13..16] CEM
        } else {
            set_bits_atomic_shared(block_idx, block_mode_p2(color_bits), 0, 11); // [00..10] Block Mode
            set_bits_atomic_shared(block_idx, 0x1, 11, 2);   // [11..12] partitions = 2
            set_bits_atomic_shared(block_idx, CEM, 13, 4);   // [13..16] CEM
            set_bits_atomic_shared(block_idx, astc_seed, 17, 10); // [17..26] Partition Seed (10 bits)
        }
    }
    subgroupBarrier();
    memoryBarrierShared();

    // First #components threads pack color endpoint components from the LUT.
    if (pixel_idx < components) {
        uint c_offset = offset + pixel_idx * color_bits;
        set_bits_atomic_shared(block_idx, c_index, c_offset, color_bits);
    }

    // All 16 threads pack their own weights
    uint w_offset = 128 - (pixel_idx + 1) * weight_bits;
    set_bits_atomic_shared(block_idx, w_index, w_offset, weight_bits);
}

void pca_endpoint_selection(vec4 my_pixel, out vec4 Ea, out vec4 Eb, out vec4 Ec, out vec4 Ed, out bool needs_2p) {
    // We will do 2 rounds of PCA
    // 1st round will find the principle direction
    // 2nd round will find the secondary direction orthogonal to the first
    // Note that the out endpoints (E1,Eb, Ec,Ed) will be uniform within a 4x4 block

    vec4 sumPixels = subgroupClusteredAdd(my_pixel, 16);
    vec4 mean = sumPixels / 16.0;
    
    // Center and Scale
    vec4 centered = my_pixel - mean;

    // primary PCA direction (dir1)
    vec4 dir1 = normalize(vec4(1.0));
    // matrix-free power iteration
    for (int i = 0; i < 4; ++i) {
        vec4 contribution = centered * dot(centered, dir1);
        vec4 newDir = subgroupClusteredAdd(contribution, 16);
        if (dot(newDir, newDir) > 1e-6) dir1 = normalize(newDir);
    }

    float projection1 = dot(centered, dir1);
    float minProj1 = subgroupClusteredMin(projection1, 16);
    float maxProj1 = subgroupClusteredMax(projection1, 16);

    Ea = mean + dir1 * minProj1;
    Eb = mean + dir1 * maxProj1;

    if (g_maximum_PC2_spread >= 2) return; // don't use 2p mode, uniform dataflow

    // secondary PCA direction (dir2)
    vec4 dir2 = normalize(vec4(0.0, 1.0, 0.0, 0.0));
    dir2 = normalize(dir2 - dir1 * dot(dir1, dir2)); // dir2 should be orthogonal to dir1

    // adapted power iteration with gram-schmid orthogonalization
    for (int i = 0; i < 4; ++i) {
        vec4 contribution = centered * dot(centered, dir2);
        vec4 newDir = subgroupClusteredAdd(contribution, 16);
        // Gram-Schmidt: remove any dir1 component to ensure orthogonality
        newDir = newDir - dir1 * dot(newDir, dir1);
        if (dot(newDir, newDir) > 1e-6) dir2 = normalize(newDir);
    }

    float projection2 = dot(centered, dir2);
    float minProj2 = subgroupClusteredMin(projection2, 16);
    float maxProj2 = subgroupClusteredMax(projection2, 16);

    Ec = mean + dir2 * minProj2;
    Ed = mean + dir2 * maxProj2;

    // The "width" of the secondary direction
    // We'll use this to heuristically evaluate if we need to do 2 partitions
    float spread_PC2 = dot(Ed - Ec, Ed - Ec);
    needs_2p = abs(spread_PC2) >= g_maximum_PC2_spread * g_maximum_PC2_spread;
}

// Calculate the squared dist of a point p to the line segment (Eb-Ea)
// by projection p onto (Eb-Ea)
float get_dist_sq(vec4 p, vec4 Ea, vec4 Eb) {
    vec4 E_delta = Eb - Ea;
    vec4 resid = p - Ea;

    float dot_delta = dot(E_delta, E_delta);
    if (dot_delta < 1e-6) {
        return dot(resid, resid); // distance to point a
    }

    float t = clamp(dot(resid, E_delta) / dot_delta, 0.0, 1.0);
    vec4 proj = Ea + E_delta * t;
    vec4 diff = p - proj;
    return dot(diff, diff); // squared distance
}

// Returns 0 if a pixel belongs to (Ea,Eb), 1 if it belongs to (Ec,Ed)
int partition_pixel_subset(vec4 pixel_rgb, vec4 Ea_rgb, vec4 Eb_rgb, vec4 Ec_rgb, vec4 Ed_rgb) 
{
    float dist1_sq = get_dist_sq(pixel_rgb, Ea_rgb, Eb_rgb);
    float dist2_sq = get_dist_sq(pixel_rgb, Ec_rgb, Ed_rgb);

    // Return the index of the closer color spectrum/line
    return (dist2_sq < dist1_sq) ? 1 : 0;
}

void main() {
    uint pixel_idx = gl_LocalInvocationID.x; // 0..15
    uint block_idx = gl_LocalInvocationID.y; // 0..3
    uint lane_id = block_idx * 16 + pixel_idx;
    uint global_block_id = gl_WorkGroupID.x * 4 + block_idx;

    if (global_block_id >= g_num_total_blocks) return;

    // Each thread loads a single vec4 pixel
    s_block_pixels[lane_id] = g_in_blocks[global_block_id * 16 + pixel_idx];
    vec4 my_pixel = s_block_pixels[lane_id];
    barrier(); // Ensure every thread finishes fetching my_pixel

    // Endpoint Selection (for two partitions).
    // (Ea,Eb) - primary partition endpoints
    // (Ec,Ed) - secondary partition endpoints
    vec4 Ea, Eb, Ec, Ed;
    bool needs_2p = false;
    if (g_use_pca > 0) {
        pca_endpoint_selection(my_pixel, Ea, Eb, Ec, Ed, needs_2p);
        // needs_2p = true; // DEBUG force 2p mode
    } else {
        // Use subgroup clustered AABB operations to compute the endpoints
        // never use 2 partitions here
        Ea = subgroupClusteredMin(my_pixel, 16);
        Eb = subgroupClusteredMax(my_pixel, 16);
    }

    // Weight calculation via projection onto Eb-Ea (proj1) and Ed-Ec (proj2)
    vec4 E_delta = Eb - Ea;
    float dot_delta = dot(E_delta, E_delta) + 1e-9f;
    float proj1 = clamp(dot(my_pixel - Ea, E_delta) / dot_delta, 0.0, 1.0);
    float proj2;

    // Ideal partition map calculation
    float proj = proj1;
    uint astc_seed = 6;
    uint my_final_partition = 0; // 0 for 1P, or 0/1 for 2P
    uint ideal_partition_idx = 0;
    uint ideal_map_int; // bitmask of where partion2 is
    if (needs_2p) { // This is an expensive O(100) divergence, but can't be optimized away
        ideal_partition_idx = partition_pixel_subset(my_pixel, Ea, Eb, Ec, Ed);
        uint idx = ideal_partition_idx == 1 ? 1u << pixel_idx : 0;
        ideal_map_int = subgroupClusteredOr(idx, 16);

        // We need to snap the ideal partition map to a valid astc partition index
        // TODO: look up ~ideal_map_int as well
        astc_seed = texelFetch(g_lut_ideal_to_seed, int(ideal_map_int)).r;
        uint final_partition_mask = texelFetch(g_lut_seed_to_mask, int(astc_seed)).r;
        // TODO: check the L1/hamming distance to ideal mask, and unset needs_2p if > 2
        my_final_partition = (final_partition_mask >> pixel_idx) & 1u;

        E_delta = Ed - Ec;
        dot_delta = dot(E_delta, E_delta) + 1e-9f;
        proj2 = clamp(dot(my_pixel - Ec, E_delta) / dot_delta, 0.0, 1.0);

        proj = (my_final_partition == 0) ? proj1 : proj2;
    }

    // Quantization
    // bool is_transparent = subgroupClusteredOr(my_alpha < 0.99f, 16);
    bool is_transparent = subgroupOr(my_pixel.a < 0.99f); // Reduces divergence if subgroup/wavefront has heterogeneous alpha

    // for partitions=2, weights are R8, otherwise, rgba is R16 while rgb is R32
    uint weight_bits = needs_2p ? (is_transparent ? WEIGHT_BITS_RGBA_2P : WEIGHT_BITS_RGB_2P) : (is_transparent ? WEIGHT_BITS_RGBA_1P : WEIGHT_BITS_RGB_1P);
    uint color_bits = needs_2p ? (is_transparent ? COLOR_BITS_RGBA_2P : COLOR_BITS_RGB_2P) : (is_transparent ? COLOR_BITS_RGBA_1P : COLOR_BITS_RGB_1P);
    uint quantized_weight = quantize_to_index(proj, weight_bits);

    // Quantize the color endpoints
    vec4[6] endpoints = {Ea, Eb, Ec, Ed, vec4(0), vec4(0)};
    uint divisor = is_transparent ? 4 : 3; // pack rgba,rgba,rgba,rgba or rgb,rgb,rgb,rgb
    float my_endpoint_component = endpoints[pixel_idx / divisor][pixel_idx % divisor];
    uint components = !needs_2p ? (is_transparent ? 8 : 6) : (is_transparent ? 16 : 12);
    uint quantized_color;
    if (pixel_idx < components) {
        quantized_color = quantize_to_index(my_endpoint_component, color_bits);
    }

    // Parallel ASTC Packing
    pack_astc_block_parallel(quantized_weight, quantized_color, components, needs_2p, color_bits, weight_bits, is_transparent, astc_seed);
    barrier();
    memoryBarrierShared();

    // Write out the packed astc to global memory
    if (pixel_idx == 0) {
        g_out_compressed_blocks[global_block_id] = s_packed_block[block_idx];
    }

    // DEBUG: write out the full encoded image as rgba8
    barrier();
    memoryBarrierShared();

    uvec4 my_packed_block = s_packed_block[block_idx];

    vec4 decoded_Ea, decoded_Eb, decoded_Ec, decoded_Ed;;
    uint decoded_weight_idx;
    uint decode_offset;
    uint decode_ep_bits = color_bits;
    uint decoded_partition;

    #define DECODE_EP_COMPONENT() dequantize_from_index(get_bits(my_packed_block, decode_offset, decode_ep_bits), decode_ep_bits); decode_offset += decode_ep_bits
    #define DECODE_EP_RGB(x) x.r = DECODE_EP_COMPONENT(); x.g = DECODE_EP_COMPONENT(); x.b = DECODE_EP_COMPONENT(); x.a = 1.0f
    #define DECODE_EP(x) x.r = DECODE_EP_COMPONENT(); x.g = DECODE_EP_COMPONENT(); x.b = DECODE_EP_COMPONENT(); if (is_transparent) { x.a = DECODE_EP_COMPONENT(); } else { x.a = 1.0f; }
    if (needs_2p) {
        decode_offset = 27;
        uint decoded_seed = get_bits(my_packed_block, 17, 10);
        uint decoded_mask = texelFetch(g_lut_seed_to_mask, int(decoded_seed)).r;
        decoded_partition = (decoded_mask >> pixel_idx) & 1u;
        // Decode 2P RGB(A) block
        // Endpoints: 12/16 channels * N bits @ offset 27
        DECODE_EP(decoded_Ea);
        DECODE_EP(decoded_Eb);
        DECODE_EP(decoded_Ec);
        DECODE_EP(decoded_Ed);

        // Weights: 16 weights * M bits
        uint weight_offset = 128 - (pixel_idx + 1) * weight_bits;
        decoded_weight_idx = get_bits(my_packed_block, weight_offset, weight_bits);
    } else {
        decode_offset = 17;
        // Decode RGB(A) block
        // Endpoints: 6/8 channels * N @ offset 17
        DECODE_EP(decoded_Ea);
        DECODE_EP(decoded_Eb);

        // Weights: 16 weights * M bits
        uint weight_offset = 128 - (pixel_idx + 1) * weight_bits;
        decoded_weight_idx = get_bits(my_packed_block, weight_offset, weight_bits);
    }

    if (decoded_partition == 1) {
        decoded_Ea = decoded_Ec;
        decoded_Eb = decoded_Ed;
    }

    // No quantization quality test
    // if (true) {
    //     // decoded_Ea = Ea;
    //     // decoded_Eb = Eb;
    //     // decoded_Ec = Ec;
    //     // decoded_Ed = Ed;
    //     // weight_bits = 8;
    //     // decoded_partition = ideal_partition_idx;
    //     // decoded_weight_idx = quantize_to_index(decoded_partition == 0 ? proj1 : proj2, weight_bits);
    // }

    float w = dequantize_from_index(decoded_weight_idx, weight_bits);

    // LERP the final color
    vec4 final_color = mix(decoded_Ea, decoded_Eb, w);

    // Highlight 2p blocks
    // if (needs_2p) {
    //     if (decoded_partition == 0) {
    //         final_color = mix(final_color, vec4(0.0, 1.0, 0.0, 1.0), 0.15);
    //     } else {
    //         final_color = mix(final_color, vec4(1.0, 0, 1.0, 1.0), 0.15);
    //     }

    //     if (ideal_partition_idx != decoded_partition) {
    //         g_out_decoded_pixels[global_block_id * 16 + pixel_idx] = decoded_partition == 0 ? vec4(0,1,0,1) : vec4(1,0,1,1);
    //         return;
    //     }
    // }

    g_out_decoded_pixels[global_block_id * 16 + pixel_idx] = final_color;
}
